<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>09-Java线程（上）：Java线程的生命周期</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <style>
        html {
            color: #333;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-rendering: optimizelegibility;
            font-family: Helvetica Neue, PingFang SC, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif
        }

        html.borderbox *,
        html.borderbox :after,
        html.borderbox :before {
            box-sizing: border-box
        }

        article,
        aside,
        blockquote,
        body,
        button,
        code,
        dd,
        details,
        dl,
        dt,
        fieldset,
        figcaption,
        figure,
        footer,
        form,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        header,
        hr,
        input,
        legend,
        li,
        menu,
        nav,
        ol,
        p,
        pre,
        section,
        td,
        textarea,
        th,
        ul {
            margin: 0;
            padding: 0
        }

        article,
        aside,
        details,
        figcaption,
        figure,
        footer,
        header,
        menu,
        nav,
        section {
            display: block
        }

        audio,
        canvas,
        video {
            display: inline-block
        }

        body,
        button,
        input,
        select,
        textarea {
            font: 300 1em/1.8 PingFang SC, Lantinghei SC, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, Helvetica, sans-serif
        }

        button::-moz-focus-inner,
        input::-moz-focus-inner {
            padding: 0;
            border: 0
        }

        table {
            border-collapse: collapse;
            border-spacing: 0
        }

        fieldset,
        img {
            border: 0
        }

        blockquote {
            position: relative;
            color: #999;
            font-weight: 400;
            border-left: 1px solid #1abc9c;
            padding-left: 1em;
            margin: 1em 3em 1em 2em
        }

        @media only screen and (max-width: 640px) {
            blockquote {
                margin: 1em 0
            }
        }

        abbr,
        acronym {
            border-bottom: 1px dotted;
            font-variant: normal
        }

        abbr {
            cursor: help
        }

        del {
            text-decoration: line-through
        }

        address,
        caption,
        cite,
        code,
        dfn,
        em,
        th,
        var {
            font-style: normal;
            font-weight: 400
        }

        ol,
        ul {
            list-style: none
        }

        caption,
        th {
            text-align: left
        }

        q:after,
        q:before {
            content: ""
        }

        sub,
        sup {
            font-size: 75%;
            line-height: 0;
            position: relative
        }

        :root sub,
        :root sup {
            vertical-align: baseline
        }

        sup {
            top: -.5em
        }

        sub {
            bottom: -.25em
        }

        a {
            color: #1abc9c
        }

        a:hover {
            text-decoration: underline
        }

        .typo a {
            border-bottom: 1px solid #1abc9c
        }

        .typo a:hover {
            border-bottom-color: #555;
            color: #555
        }

        .typo a:hover,
        a,
        ins {
            text-decoration: none
        }

        .typo-u,
        u {
            text-decoration: underline
        }

        mark {
            background: #fffdd1;
            border-bottom: 1px solid #ffedce;
            padding: 2px;
            margin: 0 5px
        }

        code,
        pre,
        pre tt {
            font-family: Courier, Courier New, monospace
        }

        pre {
            background: hsla(0, 0%, 97%, .7);
            border: 1px solid #ddd;
            padding: 1em 1.5em;
            display: block;
            -webkit-overflow-scrolling: touch
        }

        hr {
            border: none;
            border-bottom: 1px solid #cfcfcf;
            margin-bottom: .8em;
            height: 10px
        }

        .typo-small,
        figcaption,
        small {
            font-size: .9em;
            color: #888
        }

        b,
        strong {
            font-weight: 700;
            color: #000
        }

        [draggable] {
            cursor: move
        }

        .clearfix:after,
        .clearfix:before {
            content: "";
            display: table
        }

        .clearfix:after {
            clear: both
        }

        .clearfix {
            zoom: 1
        }

        .textwrap,
        .textwrap td,
        .textwrap th {
            word-wrap: break-word;
            word-break: break-all
        }

        .textwrap-table {
            table-layout: fixed
        }

        .serif {
            font-family: Palatino, Optima, Georgia, serif
        }

        .typo-dl,
        .typo-form,
        .typo-hr,
        .typo-ol,
        .typo-p,
        .typo-pre,
        .typo-table,
        .typo-ul,
        .typo dl,
        .typo form,
        .typo hr,
        .typo ol,
        .typo p,
        .typo pre,
        .typo table,
        .typo ul,
        blockquote {
            margin-bottom: 1rem
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: PingFang SC, Helvetica Neue, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif;
            color: #000;
            line-height: 1.35
        }

        .typo-h1,
        .typo-h2,
        .typo-h3,
        .typo-h4,
        .typo-h5,
        .typo-h6,
        .typo h1,
        .typo h2,
        .typo h3,
        .typo h4,
        .typo h5,
        .typo h6 {
            margin-top: 1.2em;
            margin-bottom: .6em;
            line-height: 1.35
        }

        .typo-h1,
        .typo h1 {
            font-size: 2em
        }

        .typo-h2,
        .typo h2 {
            font-size: 1.8em
        }

        .typo-h3,
        .typo h3 {
            font-size: 1.6em
        }

        .typo-h4,
        .typo h4 {
            font-size: 1.4em
        }

        .typo-h5,
        .typo-h6,
        .typo h5,
        .typo h6 {
            font-size: 1.2em
        }

        .typo-ul,
        .typo ul {
            margin-left: 1.3em;
            list-style: disc
        }

        .typo-ol,
        .typo ol {
            list-style: decimal;
            margin-left: 1.9em
        }

        .typo-ol ol,
        .typo-ol ul,
        .typo-ul ol,
        .typo-ul ul,
        .typo li ol,
        .typo li ul {
            margin-bottom: .8em;
            margin-left: 2em
        }

        .typo-ol ul,
        .typo-ul ul,
        .typo li ul {
            list-style: circle
        }

        .typo-table td,
        .typo-table th,
        .typo table caption,
        .typo table td,
        .typo table th {
            border: 1px solid #ddd;
            padding: .5em 1em;
            color: #666
        }

        .typo-table th,
        .typo table th {
            background: #fbfbfb
        }

        .typo-table thead th,
        .typo table thead th {
            background: hsla(0, 0%, 95%, .7)
        }

        .typo table caption {
            border-bottom: none
        }

        .typo-input,
        .typo-textarea {
            -webkit-appearance: none;
            border-radius: 0
        }

        .typo-em,
        .typo em,
        caption,
        legend {
            color: #000;
            font-weight: inherit
        }

        .typo-em {
            position: relative
        }

        .typo-em:after {
            position: absolute;
            top: .65em;
            left: 0;
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
            content: "\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB"
        }

        .typo img {
            max-width: 100%
        }

        .common-content {
            font-weight: 400;
            color: #353535;
            line-height: 1.75rem;
            white-space: normal;
            word-break: normal;
            font-size: 1rem
        }

        .common-content img {
            display: block;
            max-width: 100%;
            background-color: #eee
        }

        .common-content audio,
        .common-content video {
            width: 100%;
            background-color: #eee
        }

        .common-content center,
        .common-content font {
            margin-top: 1rem;
            display: inline-block
        }

        .common-content center {
            width: 100%
        }

        .common-content pre {
            margin-top: 1rem;
            padding-left: 0;
            padding-right: 0;
            position: relative;
            overflow: hidden
        }

        .common-content pre code {
            font-size: .8rem;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            width: 100%;
            box-sizing: border-box;
            padding-left: 1rem;
            padding-right: 1rem;
            overflow-x: auto
        }

        .common-content hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        .common-content b,
        .common-content h1,
        .common-content h2,
        .common-content h3,
        .common-content h4,
        .common-content h5,
        .common-content strong {
            font-weight: 700
        }

        .common-content h1,
        .common-content h2 {
            font-size: 1.125rem;
            margin-bottom: .45rem
        }

        .common-content h3,
        .common-content h4,
        .common-content h5 {
            font-size: 1rem;
            margin-bottom: .45rem
        }

        .common-content p {
            font-weight: 400;
            color: #353535;
            margin-top: .15rem
        }

        .common-content .orange {
            color: #ff5a05
        }

        .common-content .reference {
            font-size: 1rem;
            color: #888
        }

        .custom-rich-content h1 {
            margin-top: 0;
            font-weight: 400;
            font-size: 15.25px;
            border-bottom: 1px solid #eee;
            line-height: 2.8
        }

        .custom-rich-content li,
        .custom-rich-content p {
            font-size: 14px;
            color: #888;
            line-height: 1.6
        }

        table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        table.hljs-ln,
        table.hljs-ln tbody,
        table.hljs-ln td,
        table.hljs-ln tr {
            box-sizing: border-box
        }

        table.hljs-ln td {
            padding: 0;
            border: 0
        }

        table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            user-select: none
        }

        table.hljs-ln td.hljs-ln-code,
        table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            font-size: 12px;
            line-height: 20px;
            vertical-align: top
        }

        table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            color: #24292e;
            word-wrap: normal;
            white-space: pre
        }

        video::-webkit-media-controls {
            overflow: hidden !important
        }

        video::-webkit-media-controls-enclosure {
            width: calc(100% + 32px);
            margin-left: auto
        }

        ._29HP61GA_0 {
            max-width:800px;
            margin:0 auto;
            margin-bottom: 20px;
            font-weight: 400;
            color: #353535;
            line-height: 1.76;
            white-space: normal;
            word-break: normal;
            font-size: 17px;
            -webkit-transition: background-color .3s ease;
            transition: background-color .3s ease
        }

        ._29HP61GA_0 .MathJax_Display {
            overflow: auto
        }

        ._29HP61GA_0 .poster {
            position: fixed;
            left: -10000px;
            top: -10000px;
            overflow: hidden;
            padding: 1rem;
            background: #ececec
        }

        ._29HP61GA_0 .richcontent-pre-copy {
            font-size: 13px;
            color: #888;
            position: absolute;
            right: 1em;
            top: .5em;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 .richcontent-pre-copy .iconfont {
            font-size: 12px;
            margin-right: .2em
        }

        ._29HP61GA_0 a {
            color: #fa8919;
            border-bottom: 1px solid #fa8919
        }

        ._29HP61GA_0 img {
            display: block;
            max-width: 100%;
            position: relative;
            left: 50%;
            -webkit-transform: translateX(-50%);
            transform: translateX(-50%);
            background-color: #eee;
            vertical-align: top;
            border-radius: 0
        }

        ._29HP61GA_0 audio,
        ._29HP61GA_0 video {
            width: 100%;
            background-color: #eee
        }

        ._29HP61GA_0 pre {
            margin-top: 16px;
            padding: 34px 0 0;
            margin-bottom: 30px;
            position: relative;
            border-radius: 6px;
            background: rgba(246, 247, 251, .749);
            border: 0
        }

        ._29HP61GA_0 pre code {
            font-size: 12px;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
            margin-left: 16px;
            margin-right: 16px;
            overflow-x: scroll
        }

        ._29HP61GA_0 pre code:after {
            content: "";
            height: 30px;
            width: 100%;
            display: block
        }

        ._29HP61GA_0 hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        ._29HP61GA_0 h1,
        ._29HP61GA_0 h2,
        ._29HP61GA_0 h3,
        ._29HP61GA_0 h4,
        ._29HP61GA_0 h5 {
            margin-bottom: 20px;
            margin-top: 0;
            font-weight: 700
        }

        ._29HP61GA_0 b,
        ._29HP61GA_0 strong {
            font-weight: 700
        }

        ._29HP61GA_0 h1 {
            font-size: 21px
        }

        ._29HP61GA_0 h2 {
            font-size: 20px
        }

        ._29HP61GA_0 h3 {
            font-size: 19px
        }

        ._29HP61GA_0 h4 {
            font-size: 18px
        }

        ._29HP61GA_0 h5 {
            font-size: 17px
        }

        ._29HP61GA_0 center,
        ._29HP61GA_0 p {
            font-weight: 400;
            color: #353535;
            margin-top: 0;
            margin-bottom: 30px;
            word-break: break-word
        }

        ._29HP61GA_0 center {
            text-align: center
        }

        ._29HP61GA_0 blockquote {
            margin-top: 0;
            margin-bottom: 34px;
            border-left: 3px solid #e8e8e8;
            padding-left: 17px;
            color: #353535
        }

        ._29HP61GA_0 blockquote p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol,
        ._29HP61GA_0 ul {
            margin-bottom: 30px
        }

        ._29HP61GA_0 ol p,
        ._29HP61GA_0 ul p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol {
            list-style: decimal;
            margin-left: 20px
        }

        ._29HP61GA_0 ul li {
            padding-left: 17px;
            position: relative;
            margin-bottom: 10px
        }

        ._29HP61GA_0 ul li:after {
            content: "";
            height: 6px;
            width: 6px;
            border-radius: 50%;
            background: #353535;
            position: absolute;
            top: 10px;
            left: 0
        }

        ._29HP61GA_0 .orange {
            color: #fa8919
        }

        ._29HP61GA_0 .reference {
            color: #888
        }

        ._29HP61GA_0 .m-right {
            text-align: right
        }

        ._29HP61GA_0 .m-center {
            text-align: center;
            display: block
        }

        ._29HP61GA_0 .m-gray {
            color: #888
        }

        ._29HP61GA_0 .m-small {
            font-size: 15px
        }

        ._29HP61GA_0 table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        ._29HP61GA_0 table.hljs-ln,
        ._29HP61GA_0 table.hljs-ln tbody,
        ._29HP61GA_0 table.hljs-ln td,
        ._29HP61GA_0 table.hljs-ln tr {
            -webkit-box-sizing: border-box;
            box-sizing: border-box
        }

        ._29HP61GA_0 table.hljs-ln td {
            padding: 0;
            border: 0
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            font-size: 12px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code,
        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            line-height: 20px;
            vertical-align: top
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            font-size: 13px;
            color: #666;
            word-wrap: normal;
            white-space: pre
        }

    </style>
</head>
<body>
<div class="_29HP61GA_0">
<h1>09-Java线程（上）：Java线程的生命周期</h1>
<p>在Java领域，实现并发程序的主要手段就是多线程。线程是操作系统里的一个概念，虽然各种不同的开发语言如Java、C#等都对其进行了封装，但是万变不离操作系统。Java语言里的线程本质上就是操作系统的线程，它们是一一对应的。</p><p>在操作系统层面，线程也有“生老病死”，专业的说法叫有生命周期。对于有生命周期的事物，要学好它，思路非常简单，只要能搞懂<strong>生命周期中各个节点的状态转换机制</strong>就可以了。</p><p>虽然不同的开发语言对于操作系统线程进行了不同的封装，但是对于线程的生命周期这部分，基本上是雷同的。所以，我们可以先来了解一下通用的线程生命周期模型，这部分内容也适用于很多其他编程语言；然后再详细有针对性地学习一下Java中线程的生命周期。</p><h2>通用的线程生命周期</h2><p>通用的线程生命周期基本上可以用下图这个“五态模型”来描述。这五态分别是：<strong>初始状态、可运行状态、运行状态、休眠状态</strong>和<strong>终止状态</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/9b/e5/9bbc6fa7fb4d631484aa953626cf6ae5.png" alt=""></p><center><span class="reference">通用线程状态转换图——五态模型</span></center><p>这“五态模型”的详细情况如下所示。</p><ol>
<li><strong>初始状态</strong>，指的是线程已经被创建，但是还不允许分配CPU执行。这个状态属于编程语言特有的，不过这里所谓的被创建，仅仅是在编程语言层面被创建，而在操作系统层面，真正的线程还没有创建。</li>
<li><strong>可运行状态</strong>，指的是线程可以分配CPU执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配CPU执行。</li>
<li>当有空闲的CPU时，操作系统会将其分配给一个处于可运行状态的线程，被分配到CPU的线程的状态就转换成了<strong>运行状态</strong>。</li>
<li>运行状态的线程如果调用一个阻塞的API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），那么线程的状态就会转换到<strong>休眠状态</strong>，同时释放CPU使用权，休眠状态的线程永远没有机会获得CPU使用权。当等待的事件出现了，线程就会从休眠状态转换到可运行状态。</li>
<li>线程执行完或者出现异常就会进入<strong>终止状态</strong>，终止状态的线程不会切换到其他任何状态，进入终止状态也就意味着线程的生命周期结束了。</li>
</ol><!-- [[[read_end]]] --><p>这五种状态在不同编程语言里会有简化合并。例如，C语言的POSIX Threads规范，就把初始状态和可运行状态合并了；Java语言里则把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而JVM层面不关心这两个状态，因为JVM把线程调度交给操作系统处理了。</p><p>除了简化合并，这五种状态也有可能被细化，比如，Java语言里就细化了休眠状态（这个下面我们会详细讲解）。</p><h2>Java中线程的生命周期</h2><p>介绍完通用的线程生命周期模型，想必你已经对线程的“生老病死”有了一个大致的了解。那接下来我们就来详细看看Java语言里的线程生命周期是什么样的。</p><p>Java语言中线程共有六种状态，分别是：</p><ol>
<li>NEW（初始化状态）</li>
<li>RUNNABLE（可运行/运行状态）</li>
<li>BLOCKED（阻塞状态）</li>
<li>WAITING（无时限等待）</li>
<li>TIMED_WAITING（有时限等待）</li>
<li>TERMINATED（终止状态）</li>
</ol><p>这看上去挺复杂的，状态类型也比较多。但其实在操作系统层面，Java线程中的BLOCKED、WAITING、TIMED_WAITING是一种状态，即前面我们提到的休眠状态。也就是说<strong>只要Java线程处于这三种状态之一，那么这个线程就永远没有CPU的使用权</strong>。</p><p>所以Java线程的生命周期可以简化为下图：</p><p><img src="https://static001.geekbang.org/resource/image/3f/8c/3f6c6bf95a6e8627bdf3cb621bbb7f8c.png" alt=""></p><center><span class="reference">Java中的线程状态转换图</span></center><p>其中，BLOCKED、WAITING、TIMED_WAITING可以理解为线程导致休眠状态的三种原因。那具体是哪些情形会导致线程从RUNNABLE状态转换到这三种状态呢？而这三种状态又是何时转换回RUNNABLE的呢？以及NEW、TERMINATED和RUNNABLE状态是如何转换的？</p><h3>1. RUNNABLE与BLOCKED的状态转换</h3><p>只有一种场景会触发这种转换，就是线程等待synchronized的隐式锁。synchronized修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从RUNNABLE转换到BLOCKED状态。而当等待的线程获得synchronized隐式锁时，就又会从BLOCKED转换到RUNNABLE状态。</p><p>如果你熟悉操作系统线程的生命周期的话，可能会有个疑问：线程调用阻塞式API时，是否会转换到BLOCKED状态呢？在操作系统层面，线程是会转换到休眠状态的，但是在JVM层面，Java线程的状态不会发生变化，也就是说Java线程的状态会依然保持RUNNABLE状态。<strong>JVM层面并不关心操作系统调度相关的状态</strong>，因为在JVM看来，等待CPU使用权（操作系统层面此时处于可执行状态）与等待I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了RUNNABLE状态。</p><p>而我们平时所谓的Java在调用阻塞式API时，线程会阻塞，指的是操作系统线程的状态，并不是Java线程的状态。</p><h3>2. RUNNABLE与WAITING的状态转换</h3><p>总体来说，有三种场景会触发这种转换。</p><p>第一种场景，获得synchronized隐式锁的线程，调用无参数的Object.wait()方法。其中，wait()方法我们在上一篇讲解管程的时候已经深入介绍过了，这里就不再赘述。</p><p>第二种场景，调用无参数的Thread.join()方法。其中的join()是一种线程同步方法，例如有一个线程对象thread A，当调用A.join()的时候，执行这条语句的线程会等待thread A执行完，而等待中的这个线程，其状态会从RUNNABLE转换到WAITING。当线程thread A执行完，原来等待它的线程又会从WAITING状态转换到RUNNABLE。</p><p>第三种场景，调用LockSupport.park()方法。其中的LockSupport对象，也许你有点陌生，其实Java并发包中的锁，都是基于它实现的。调用LockSupport.park()方法，当前线程会阻塞，线程的状态会从RUNNABLE转换到WAITING。调用LockSupport.unpark(Thread thread)可唤醒目标线程，目标线程的状态又会从WAITING状态转换到RUNNABLE。</p><h3>3. RUNNABLE与TIMED_WAITING的状态转换</h3><p>有五种场景会触发这种转换：</p><ol>
<li>调用<strong>带超时参数</strong>的Thread.sleep(long millis)方法；</li>
<li>获得synchronized隐式锁的线程，调用<strong>带超时参数</strong>的Object.wait(long timeout)方法；</li>
<li>调用<strong>带超时参数</strong>的Thread.join(long millis)方法；</li>
<li>调用<strong>带超时参数</strong>的LockSupport.parkNanos(Object blocker, long deadline)方法；</li>
<li>调用<strong>带超时参数</strong>的LockSupport.parkUntil(long deadline)方法。</li>
</ol><p>这里你会发现TIMED_WAITING和WAITING状态的区别，仅仅是触发条件多了<strong>超时参数</strong>。</p><h3>4. 从NEW到RUNNABLE状态</h3><p>Java刚创建出来的Thread对象就是NEW状态，而创建Thread对象主要有两种方法。一种是继承Thread对象，重写run()方法。示例代码如下：</p><pre><code>// 自定义线程对象
class MyThread extends Thread {
  public void run() {
    // 线程需要执行的代码
    ......
  }
}
// 创建线程对象
MyThread myThread = new MyThread();
</code></pre><p>另一种是实现Runnable接口，重写run()方法，并将该实现类作为创建Thread对象的参数。示例代码如下：</p><pre><code>// 实现Runnable接口
class Runner implements Runnable {
  @Override
  public void run() {
    // 线程需要执行的代码
    ......
  }
}
// 创建线程对象
Thread thread = new Thread(new Runner());
</code></pre><p>NEW状态的线程，不会被操作系统调度，因此不会执行。Java线程要执行，就必须转换到RUNNABLE状态。从NEW状态转换到RUNNABLE状态很简单，只要调用线程对象的start()方法就可以了，示例代码如下：</p><pre><code>MyThread myThread = new MyThread();
// 从NEW状态转换到RUNNABLE状态
myThread.start()；
</code></pre><h3>5. 从RUNNABLE到TERMINATED状态</h3><p>线程执行完 run() 方法后，会自动转换到TERMINATED状态，当然如果执行run()方法的时候异常抛出，也会导致线程终止。有时候我们需要强制中断run()方法的执行，例如 run()方法访问一个很慢的网络，我们等不下去了，想终止怎么办呢？Java的Thread类里面倒是有个stop()方法，不过已经标记为@Deprecated，所以不建议使用了。正确的姿势其实是调用interrupt()方法。</p><p><strong>那stop()和interrupt()方法的主要区别是什么呢？</strong></p><p>stop()方法会真的杀死线程，不给线程喘息的机会，如果线程持有ReentrantLock锁，被stop()的线程并不会自动调用ReentrantLock的unlock()去释放锁，那其他线程就再也没机会获得ReentrantLock锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有suspend() 和 resume()方法，这两个方法同样也都不建议使用了，所以这里也就不多介绍了。</p><p>而interrupt()方法就温柔多了，interrupt()方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被interrupt的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。</p><p>当线程A处于WAITING、TIMED_WAITING状态时，如果其他线程调用线程A的interrupt()方法，会使线程A返回到RUNNABLE状态，同时线程A的代码会触发InterruptedException异常。上面我们提到转换到WAITING、TIMED_WAITING状态的触发条件，都是调用了类似wait()、join()、sleep()这样的方法，我们看这些方法的签名，发现都会throws InterruptedException这个异常。这个异常的触发条件就是：其他线程调用了该线程的interrupt()方法。</p><p>当线程A处于RUNNABLE状态时，并且阻塞在java.nio.channels.InterruptibleChannel上时，如果其他线程调用线程A的interrupt()方法，线程A会触发java.nio.channels.ClosedByInterruptException这个异常；而阻塞在java.nio.channels.Selector上时，如果其他线程调用线程A的interrupt()方法，线程A的java.nio.channels.Selector会立即返回。</p><p>上面这两种情况属于被中断的线程通过异常的方式获得了通知。还有一种是主动检测，如果线程处于RUNNABLE状态，并且没有阻塞在某个I/O操作上，例如中断计算圆周率的线程A，这时就得依赖线程A主动检测中断状态了。如果其他线程调用线程A的interrupt()方法，那么线程A可以通过isInterrupted()方法，检测是不是自己被中断了。</p><h2>总结</h2><p>理解Java线程的各种状态以及生命周期对于诊断多线程Bug非常有帮助，多线程程序很难调试，出了Bug基本上都是靠日志，靠线程dump来跟踪问题，分析线程dump的一个基本功就是分析线程状态，大部分的死锁、饥饿、活锁问题都需要跟踪分析线程的状态。同时，本文介绍的线程生命周期具备很强的通用性，对于学习其他语言的多线程编程也有很大的帮助。</p><p>你可以通过 <code>jstack</code> 命令或者<code>Java VisualVM</code>这个可视化工具将JVM所有的线程栈信息导出来，完整的线程栈信息不仅包括线程的当前状态、调用栈，还包括了锁的信息。例如，我曾经写过一个死锁的程序，导出的线程栈明确告诉我发生了死锁，并且将死锁线程的调用栈信息清晰地显示出来了（如下图）。导出线程栈，分析线程状态是诊断并发问题的一个重要工具。</p><p><img src="https://static001.geekbang.org/resource/image/67/be/67734e1a062adc7cf7baac7d6c17ddbe.png" alt=""></p><center><span class="reference">发生死锁的线程栈</span></center><h2>课后思考</h2><p>下面代码的本意是当前线程被中断之后，退出<code>while(true)</code>，你觉得这段代码是否正确呢？</p><pre><code>Thread th = Thread.currentThread();
while(true) {
  if(th.isInterrupted()) {
    break;
  }
  // 省略业务代码无数
  try {
    Thread.sleep(100);
  }catch (InterruptedException e){
    e.printStackTrace();
  }
}
</code></pre><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><h1>猜你喜欢</h1><p><a href="https://time.geekbang.org/course/intro/156?utm_term=zeusRVDGT&amp;utm_source=app&amp;utm_medium=javabingfabiancheng&amp;utm_campaign=156-onsell&amp;utm_content=banner0301"><img src="https://static001.geekbang.org/resource/image/8e/93/8e1906fb8a24d5eb66539fa88ea56193.png" alt="unpreview"></a></p><h2>精选留言：</h2>
        <ul>
        
<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            姜戈  2019-03-19 01:06:39
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            可能出现无限循环，线程在sleep期间被打断了，抛出一个InterruptedException异常，try catch捕捉此异常，应该重置一下中断标示，因为抛出异常后，中断标示会自动清除掉！<br>Thread th = Thread.currentThread();<br>while(true) {<br>  if(th.isInterrupted()) {<br>    break;<br>  }<br>  &#47;&#47; 省略业务代码无数<br>  try {<br>    Thread.sleep(100);<br>  }catch (InterruptedException e)｛<br>    Thread.currentThread().interrupt();<br>    e.printStackTrace();<br>  }<br>} [64赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-19 07:54:42</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">👍👍👍<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            Geek_961eed  2019-03-19 10:41:32
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            希望作者讲解一下每一期的思考题！ [27赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            虎虎❤️  2019-03-19 12:33:32
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            我的一位长辈曾告诉我，没有真正学不会的知识或者技术，只是缺乏好的老师。<br><br>有的人可以把复杂的知识讲明白，但是讲解的过程却也是晦涩难懂，不免落了下成。<br><br>而学习王老师的课，我一直都觉得很轻松。云淡风轻地就把并发知识抽丝剥茧，确是更显功力。另一方面，我觉得人的大脑更喜欢接受这些平易近人的文字。看似浅近的文字，却更能带领我深入的思考，留下更深刻的印象。反观一些看起来高端大气上档次的论述，让人觉得云山雾罩，好不容易看懂了，但看过后却什么也想不起来了。大概是读文章的时候脑细胞都用来和晦涩的文字做斗争了，已经没有空间去思考和记忆了。<br><br>再次感谢王老师给大家带来优秀的课程。 [16赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-19 20:11:21</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">看来我没必要写的很装了😂<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            thas  2019-03-19 15:40:18
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            interrupt是中断的意思，在单片机开发领域，用于接收特定的事件，从而执行后续的操作。Java线程中，（通常）使用interrupt作为线程退出的通知事件，告知线程可以结束了。<br>interrupt不会结束线程的运行，在抛出InterruptedException后会清除中断标志（代表可以接收下一个中断信号了），所以我想，interrupt应该也是可以类似单片机一样作为一种通知信号的，只是实现通知的话，Java有其他更好的选择。<br>因InterruptedException退出同步代码块会释放当前线程持有的锁，所以相比外部强制stop是安全的（已手动测试）。sleep、join等会抛出InterruptedException的操作会立即抛出异常，wait在被唤醒之后才会抛出异常（就像阻塞一样，不被打扰）。<br>另外，感谢老师提醒，I&#47;O阻塞在Java中是可运行状态，并发包中的lock是等待状态。 [7赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-19 20:04:43</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">能和硬件中断联系起来👍👍👍<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            悟  2019-03-19 12:23:52
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            老师 stop方法直接杀掉线程了，什么不会释放锁呢 [6赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-19 20:12:36</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">我也不知道搞jvm的人咋想的<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            向往的生活  2019-03-19 15:15:41
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。此时如果线程A获取不到锁，岂不是会立马又变成BLOCKED 状态？ [4赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-20 08:39:40</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">我估计不会有中间的runnable，只是换个队列而已<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            alias cd=rm -rf  2019-03-19 10:10:39
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            思考题，不能中断循环，异常捕获要放在while循环外面<br> [3赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-19 20:20:18</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">你这也是个办法<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            Junzi  2019-03-26 10:08:10
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            当发起中断之后，Thread.sleep(100);会抛出InterruptedException异常，而这个抛出这个异常会清除当前线程的中断标识，导致th.isInterrupted()一直都是返回false的。<br><br>InterruptedException - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown. [2赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-28 21:51:35</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">👍</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            忠艾一生  2019-03-19 22:55:38
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            这段代码中的线程对象并没有调用th.interrupt（）,只是调用了sleep()方法，此时线程并没有中断，也不会发生异常，sleep（）过后，线程继续自动执行。所以也不会进入到if代码块。<br>不知道我说的对不对啊老师。。。 [2赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            刘晓林  2019-03-19 18:48:44
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            感谢老师提醒，原来jvm层面的线程状态和os层面上的线程状态是不一样的，i&#47;o挂起在jvm也是runable状态。另外并发包的lock其实是处于waitting状态。<br>但是有个疑问，jvm中blocked状态的线程和waitting状态的线程，除了处在不同的队列之外，还有没有什么区别呀？我这里问的区别包括jvm和os两个层面，谢谢老师 [2赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-20 08:33:15</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">block不能响应中断，os里应该都是休眠状态，因为都不能获得cpu使用权<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            缪文@有赞  2019-04-02 23:07:27
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            if(th.isInterrupted()) {<br>    break;<br>  }<br>其实这段代码完全没必要啊，在捕获中断异常后，直接break就好了 [1赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            ^_^  2019-03-28 18:28:43
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            class MyThread extends Thread {<br>      @Override<br>       public void run() {<br>      }<br>}<br> [1赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            ren  2019-03-26 22:44:51
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            老师。那么jvm在进行gc的时候的停顿所有线程(stw) 这个期间 jvm中的线程应该属于生命周期的哪一个状态呢？ 我看到有资料讲的是 jvm中的线程 会因为jvm设置的安全点和安全区域 执行test指令产生一个自陷异常信号 这个指令应该是汇编中的触发线程中断的 那么之后的恢复成运行状态也都是交给操作系统层面来实现的吗？ [1赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-27 09:03:46</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">线程调度是交给操作系统的，stw期间你看到的线程状态和stw之前应该是一样的，java里的线程状态是给你看的，没必要让你看到不该看的。但是stw期间操作系统层面的状态应该都是阻塞态，不允许调度。这个要看jvm的具体实现<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            linqw  2019-03-24 22:57:52
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            老师，不知道能否在理论讲解清楚的同时也能补上对源码的分析，比如线程a的interrupt方法被其他线程调用，有两种形式检测，异常和使用isInterrupted检测，但是内部原理还是感觉不清楚不明白，根据异常它是如何中断的？还有java有阻塞和等待状态，但是没能理解java为什么要将其区分开来，比如阻塞是在获取不到锁阻塞，会在锁对象中的队列排队，wait等待状态，不是也会在调用的对象队列中排队么？不太清楚为什么要怎么做？ [1赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-25 08:44:48</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">我尽量不讲源码，讲源码的书有好多，感兴趣的可以去参考。也不回拿出汇编来讲解怎么实现的，网上也有很多。听完这个专栏去再去看代码，你会觉得很简单。<br><br>区分这么多状态的原因我也没有深究，可能是历史原因，如果并发包里的锁也搞一状态，可能会更乱<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            Docker  2019-03-20 17:37:21
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            测试过了，确实一个线程获取不到锁，线程状态为blocked [1赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            Zach_  2019-03-20 12:16:21
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            <br>public class TestThread {<br><br>	public static void main(String[] args) throws InterruptedException {<br><br>		Worker t = new Worker();<br>		t.start();<br><br>		Thread.sleep(2000);<br>		<br>		System.out.println(&quot;-1-1-1-&quot;);<br>		t.interrupt();<br>		System.out.println(&quot;000000&quot;);<br>		Thread.sleep(2000);<br>		t.stop();<br>		System.out.println(&quot;000111&quot;);<br>		Thread.sleep(2000);<br>		t.join();<br>		System.out.println(&quot;111111&quot;);<br>	}<br><br>}<br><br>class Worker extends Thread {<br><br>	@Override<br>	public void run() {<br>		int i = 0;<br>		while (i&lt;20) {<br>			if (Thread.currentThread().isInterrupted()) {<br>				break;<br>			}<br>			++i;<br>			System.out.println(Thread.currentThread().getName() + &quot;i: &quot; + i);<br>			try {<br>				Thread.sleep(1000);<br>			} catch (InterruptedException e) {<br>				&#47;&#47; TODO Auto-generated catch block<br>				e.printStackTrace();<br>			}<br>		}<br>	}<br>}<br><br>----------------------------------------------------------------------------<br>忽然发现极客时间网页版的留言窗口好小啊，都看不到自己上面写的东西...<br>----------------------------------------------------------------------------<br><br>1. 如果worker中没有sleep方法，则调用th.interrupt()方法会真正的中断th线程，并且不会抛出InterruptException 但是该演示代码不能体现锁的释放；<br>2. 如果worer中有sleep方法，则调用th.interrupt()方法会抛 java.lang.InterruptException(), 是针对sleep方法抛出的<br>	同样的Object的wait() wait(带参) 也会抛出java.lang.InterruptException()而从当前的wait&#47;blocked状态被中断（唤醒）<br>	那也就是说，throws InterruptedException 的方法 在线程被调用interrupt()方法后，会被从当前状态中断<br>	至于调用interrupy()方法后线程的状态属于哪种，取决于interrupt方法前的执行的方法使得当前线程处于哪种状态，<br>	老师的总结很到位，需要好好理解，感受~！<br>3. 无论worder的run中有没有slee()方法，stop都会直接中断线程，当前演示代码也无法演示锁没有被释放<br>4. join()总是在等待被调用的线程执行完毕<br>5. while循环放在try里面, 在调用th.interrupt之后，可以有效捕获InterruptException 从而使th线程中断<br><br>说的有点多了， 大家多多讨论~！~！~！<br><br> [1赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-22 20:30:16</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">好认真👍👍👍<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            海鸿  2019-03-19 19:29:00
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            如果线程处于阻塞状态（BLOCKED）,此时调用线程的中断方法，线程会又如何反应?<br>是否会像等待状态一样抛异常?<br>还是会像运行状态一样被标记为已中断状态?<br>还是不受到任何影响?<br>麻烦老师解答一下😁 [1赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-20 08:23:28</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">阻塞态的线程不响应中断，并发包里的锁有方法能够响应中断<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            小华  2019-03-19 07:53:38
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            isInterrupted方法只是检测线程是否被标记为了中断状态，而不会改变线程的中断状态，代码中，没有调用线程的interrupted方法，所以线程的中断状态为false，while循环不会退出，也不会拋InterruptedException [1赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            不靠谱的琴谱  2019-03-19 06:41:25
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            线程处于runnable时可以退出，思考题大部分处于 wait_timed状态，并且吞了异常；所以有那么一丢丢的几率会退出，大部分情况无法退出 [1赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            Tristan  2019-04-14 10:31:46
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            为什么实战高并发程序设计医术中写道“Tread.stop()方法在结束线程时，会直接终止线程，并且会释放这个线程所持有的锁”，而您文中所写的“果线程持有 synchronized 隐式锁，也不会释放”？？ 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-04-14 17:18:48</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">是我的错，我确认了一下，隐式锁可以释放。多谢多谢！！！<br></div>
</div>
            
    </div>
</li>
            </ul>
</div>
</body>
</html>