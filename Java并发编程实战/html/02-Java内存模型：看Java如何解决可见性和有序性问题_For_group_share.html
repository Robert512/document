<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>02-Java内存模型：看Java如何解决可见性和有序性问题</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <style>
        html {
            color: #333;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-rendering: optimizelegibility;
            font-family: Helvetica Neue, PingFang SC, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif
        }

        html.borderbox *,
        html.borderbox :after,
        html.borderbox :before {
            box-sizing: border-box
        }

        article,
        aside,
        blockquote,
        body,
        button,
        code,
        dd,
        details,
        dl,
        dt,
        fieldset,
        figcaption,
        figure,
        footer,
        form,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        header,
        hr,
        input,
        legend,
        li,
        menu,
        nav,
        ol,
        p,
        pre,
        section,
        td,
        textarea,
        th,
        ul {
            margin: 0;
            padding: 0
        }

        article,
        aside,
        details,
        figcaption,
        figure,
        footer,
        header,
        menu,
        nav,
        section {
            display: block
        }

        audio,
        canvas,
        video {
            display: inline-block
        }

        body,
        button,
        input,
        select,
        textarea {
            font: 300 1em/1.8 PingFang SC, Lantinghei SC, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, Helvetica, sans-serif
        }

        button::-moz-focus-inner,
        input::-moz-focus-inner {
            padding: 0;
            border: 0
        }

        table {
            border-collapse: collapse;
            border-spacing: 0
        }

        fieldset,
        img {
            border: 0
        }

        blockquote {
            position: relative;
            color: #999;
            font-weight: 400;
            border-left: 1px solid #1abc9c;
            padding-left: 1em;
            margin: 1em 3em 1em 2em
        }

        @media only screen and (max-width: 640px) {
            blockquote {
                margin: 1em 0
            }
        }

        abbr,
        acronym {
            border-bottom: 1px dotted;
            font-variant: normal
        }

        abbr {
            cursor: help
        }

        del {
            text-decoration: line-through
        }

        address,
        caption,
        cite,
        code,
        dfn,
        em,
        th,
        var {
            font-style: normal;
            font-weight: 400
        }

        ol,
        ul {
            list-style: none
        }

        caption,
        th {
            text-align: left
        }

        q:after,
        q:before {
            content: ""
        }

        sub,
        sup {
            font-size: 75%;
            line-height: 0;
            position: relative
        }

        :root sub,
        :root sup {
            vertical-align: baseline
        }

        sup {
            top: -.5em
        }

        sub {
            bottom: -.25em
        }

        a {
            color: #1abc9c
        }

        a:hover {
            text-decoration: underline
        }

        .typo a {
            border-bottom: 1px solid #1abc9c
        }

        .typo a:hover {
            border-bottom-color: #555;
            color: #555
        }

        .typo a:hover,
        a,
        ins {
            text-decoration: none
        }

        .typo-u,
        u {
            text-decoration: underline
        }

        mark {
            background: #fffdd1;
            border-bottom: 1px solid #ffedce;
            padding: 2px;
            margin: 0 5px
        }

        code,
        pre,
        pre tt {
            font-family: Courier, Courier New, monospace
        }

        pre {
            background: hsla(0, 0%, 97%, .7);
            border: 1px solid #ddd;
            padding: 1em 1.5em;
            display: block;
            -webkit-overflow-scrolling: touch
        }

        hr {
            border: none;
            border-bottom: 1px solid #cfcfcf;
            margin-bottom: .8em;
            height: 10px
        }

        .typo-small,
        figcaption,
        small {
            font-size: .9em;
            color: #888
        }

        b,
        strong {
            font-weight: 700;
            color: #000
        }

        [draggable] {
            cursor: move
        }

        .clearfix:after,
        .clearfix:before {
            content: "";
            display: table
        }

        .clearfix:after {
            clear: both
        }

        .clearfix {
            zoom: 1
        }

        .textwrap,
        .textwrap td,
        .textwrap th {
            word-wrap: break-word;
            word-break: break-all
        }

        .textwrap-table {
            table-layout: fixed
        }

        .serif {
            font-family: Palatino, Optima, Georgia, serif
        }

        .typo-dl,
        .typo-form,
        .typo-hr,
        .typo-ol,
        .typo-p,
        .typo-pre,
        .typo-table,
        .typo-ul,
        .typo dl,
        .typo form,
        .typo hr,
        .typo ol,
        .typo p,
        .typo pre,
        .typo table,
        .typo ul,
        blockquote {
            margin-bottom: 1rem
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: PingFang SC, Helvetica Neue, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif;
            color: #000;
            line-height: 1.35
        }

        .typo-h1,
        .typo-h2,
        .typo-h3,
        .typo-h4,
        .typo-h5,
        .typo-h6,
        .typo h1,
        .typo h2,
        .typo h3,
        .typo h4,
        .typo h5,
        .typo h6 {
            margin-top: 1.2em;
            margin-bottom: .6em;
            line-height: 1.35
        }

        .typo-h1,
        .typo h1 {
            font-size: 2em
        }

        .typo-h2,
        .typo h2 {
            font-size: 1.8em
        }

        .typo-h3,
        .typo h3 {
            font-size: 1.6em
        }

        .typo-h4,
        .typo h4 {
            font-size: 1.4em
        }

        .typo-h5,
        .typo-h6,
        .typo h5,
        .typo h6 {
            font-size: 1.2em
        }

        .typo-ul,
        .typo ul {
            margin-left: 1.3em;
            list-style: disc
        }

        .typo-ol,
        .typo ol {
            list-style: decimal;
            margin-left: 1.9em
        }

        .typo-ol ol,
        .typo-ol ul,
        .typo-ul ol,
        .typo-ul ul,
        .typo li ol,
        .typo li ul {
            margin-bottom: .8em;
            margin-left: 2em
        }

        .typo-ol ul,
        .typo-ul ul,
        .typo li ul {
            list-style: circle
        }

        .typo-table td,
        .typo-table th,
        .typo table caption,
        .typo table td,
        .typo table th {
            border: 1px solid #ddd;
            padding: .5em 1em;
            color: #666
        }

        .typo-table th,
        .typo table th {
            background: #fbfbfb
        }

        .typo-table thead th,
        .typo table thead th {
            background: hsla(0, 0%, 95%, .7)
        }

        .typo table caption {
            border-bottom: none
        }

        .typo-input,
        .typo-textarea {
            -webkit-appearance: none;
            border-radius: 0
        }

        .typo-em,
        .typo em,
        caption,
        legend {
            color: #000;
            font-weight: inherit
        }

        .typo-em {
            position: relative
        }

        .typo-em:after {
            position: absolute;
            top: .65em;
            left: 0;
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
            content: "\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB"
        }

        .typo img {
            max-width: 100%
        }

        .common-content {
            font-weight: 400;
            color: #353535;
            line-height: 1.75rem;
            white-space: normal;
            word-break: normal;
            font-size: 1rem
        }

        .common-content img {
            display: block;
            max-width: 100%;
            background-color: #eee
        }

        .common-content audio,
        .common-content video {
            width: 100%;
            background-color: #eee
        }

        .common-content center,
        .common-content font {
            margin-top: 1rem;
            display: inline-block
        }

        .common-content center {
            width: 100%
        }

        .common-content pre {
            margin-top: 1rem;
            padding-left: 0;
            padding-right: 0;
            position: relative;
            overflow: hidden
        }

        .common-content pre code {
            font-size: .8rem;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            width: 100%;
            box-sizing: border-box;
            padding-left: 1rem;
            padding-right: 1rem;
            overflow-x: auto
        }

        .common-content hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        .common-content b,
        .common-content h1,
        .common-content h2,
        .common-content h3,
        .common-content h4,
        .common-content h5,
        .common-content strong {
            font-weight: 700
        }

        .common-content h1,
        .common-content h2 {
            font-size: 1.125rem;
            margin-bottom: .45rem
        }

        .common-content h3,
        .common-content h4,
        .common-content h5 {
            font-size: 1rem;
            margin-bottom: .45rem
        }

        .common-content p {
            font-weight: 400;
            color: #353535;
            margin-top: .15rem
        }

        .common-content .orange {
            color: #ff5a05
        }

        .common-content .reference {
            font-size: 1rem;
            color: #888
        }

        .custom-rich-content h1 {
            margin-top: 0;
            font-weight: 400;
            font-size: 15.25px;
            border-bottom: 1px solid #eee;
            line-height: 2.8
        }

        .custom-rich-content li,
        .custom-rich-content p {
            font-size: 14px;
            color: #888;
            line-height: 1.6
        }

        table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        table.hljs-ln,
        table.hljs-ln tbody,
        table.hljs-ln td,
        table.hljs-ln tr {
            box-sizing: border-box
        }

        table.hljs-ln td {
            padding: 0;
            border: 0
        }

        table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            user-select: none
        }

        table.hljs-ln td.hljs-ln-code,
        table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            font-size: 12px;
            line-height: 20px;
            vertical-align: top
        }

        table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            color: #24292e;
            word-wrap: normal;
            white-space: pre
        }

        video::-webkit-media-controls {
            overflow: hidden !important
        }

        video::-webkit-media-controls-enclosure {
            width: calc(100% + 32px);
            margin-left: auto
        }

        ._29HP61GA_0 {
            max-width:800px;
            margin:0 auto;
            margin-bottom: 20px;
            font-weight: 400;
            color: #353535;
            line-height: 1.76;
            white-space: normal;
            word-break: normal;
            font-size: 17px;
            -webkit-transition: background-color .3s ease;
            transition: background-color .3s ease
        }

        ._29HP61GA_0 .MathJax_Display {
            overflow: auto
        }

        ._29HP61GA_0 .poster {
            position: fixed;
            left: -10000px;
            top: -10000px;
            overflow: hidden;
            padding: 1rem;
            background: #ececec
        }

        ._29HP61GA_0 .richcontent-pre-copy {
            font-size: 13px;
            color: #888;
            position: absolute;
            right: 1em;
            top: .5em;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 .richcontent-pre-copy .iconfont {
            font-size: 12px;
            margin-right: .2em
        }

        ._29HP61GA_0 a {
            color: #fa8919;
            border-bottom: 1px solid #fa8919
        }

        ._29HP61GA_0 img {
            display: block;
            max-width: 100%;
            position: relative;
            left: 50%;
            -webkit-transform: translateX(-50%);
            transform: translateX(-50%);
            background-color: #eee;
            vertical-align: top;
            border-radius: 0
        }

        ._29HP61GA_0 audio,
        ._29HP61GA_0 video {
            width: 100%;
            background-color: #eee
        }

        ._29HP61GA_0 pre {
            margin-top: 16px;
            padding: 34px 0 0;
            margin-bottom: 30px;
            position: relative;
            border-radius: 6px;
            background: rgba(246, 247, 251, .749);
            border: 0
        }

        ._29HP61GA_0 pre code {
            font-size: 12px;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
            margin-left: 16px;
            margin-right: 16px;
            overflow-x: scroll
        }

        ._29HP61GA_0 pre code:after {
            content: "";
            height: 30px;
            width: 100%;
            display: block
        }

        ._29HP61GA_0 hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        ._29HP61GA_0 h1,
        ._29HP61GA_0 h2,
        ._29HP61GA_0 h3,
        ._29HP61GA_0 h4,
        ._29HP61GA_0 h5 {
            margin-bottom: 20px;
            margin-top: 0;
            font-weight: 700
        }

        ._29HP61GA_0 b,
        ._29HP61GA_0 strong {
            font-weight: 700
        }

        ._29HP61GA_0 h1 {
            font-size: 21px
        }

        ._29HP61GA_0 h2 {
            font-size: 20px
        }

        ._29HP61GA_0 h3 {
            font-size: 19px
        }

        ._29HP61GA_0 h4 {
            font-size: 18px
        }

        ._29HP61GA_0 h5 {
            font-size: 17px
        }

        ._29HP61GA_0 center,
        ._29HP61GA_0 p {
            font-weight: 400;
            color: #353535;
            margin-top: 0;
            margin-bottom: 30px;
            word-break: break-word
        }

        ._29HP61GA_0 center {
            text-align: center
        }

        ._29HP61GA_0 blockquote {
            margin-top: 0;
            margin-bottom: 34px;
            border-left: 3px solid #e8e8e8;
            padding-left: 17px;
            color: #353535
        }

        ._29HP61GA_0 blockquote p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol,
        ._29HP61GA_0 ul {
            margin-bottom: 30px
        }

        ._29HP61GA_0 ol p,
        ._29HP61GA_0 ul p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol {
            list-style: decimal;
            margin-left: 20px
        }

        ._29HP61GA_0 ul li {
            padding-left: 17px;
            position: relative;
            margin-bottom: 10px
        }

        ._29HP61GA_0 ul li:after {
            content: "";
            height: 6px;
            width: 6px;
            border-radius: 50%;
            background: #353535;
            position: absolute;
            top: 10px;
            left: 0
        }

        ._29HP61GA_0 .orange {
            color: #fa8919
        }

        ._29HP61GA_0 .reference {
            color: #888
        }

        ._29HP61GA_0 .m-right {
            text-align: right
        }

        ._29HP61GA_0 .m-center {
            text-align: center;
            display: block
        }

        ._29HP61GA_0 .m-gray {
            color: #888
        }

        ._29HP61GA_0 .m-small {
            font-size: 15px
        }

        ._29HP61GA_0 table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        ._29HP61GA_0 table.hljs-ln,
        ._29HP61GA_0 table.hljs-ln tbody,
        ._29HP61GA_0 table.hljs-ln td,
        ._29HP61GA_0 table.hljs-ln tr {
            -webkit-box-sizing: border-box;
            box-sizing: border-box
        }

        ._29HP61GA_0 table.hljs-ln td {
            padding: 0;
            border: 0
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            font-size: 12px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code,
        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            line-height: 20px;
            vertical-align: top
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            font-size: 13px;
            color: #666;
            word-wrap: normal;
            white-space: pre
        }

    </style>
</head>
<body>
<div class="_29HP61GA_0">
<h1>02-Java内存模型：看Java如何解决可见性和有序性问题</h1>
<p>上一期我们讲到在并发场景中，因可见性、原子性、有序性导致的问题常常会违背我们的直觉，从而成为并发编程的Bug之源。这三者在编程领域属于共性问题，所有的编程语言都会遇到，Java在诞生之初就支持多线程，自然也有针对这三者的技术方案，而且在编程语言领域处于领先地位。理解Java解决并发问题的解决方案，对于理解其他语言的解决方案有触类旁通的效果。</p><p>那我们就先来聊聊如何解决其中的可见性和有序性导致的问题，这也就引出来了今天的主角——<strong>Java内存模型</strong>。</p><p>Java内存模型这个概念，在职场的很多面试中都会考核到，是一个热门的考点，也是一个人并发水平的具体体现。原因是当并发程序出问题时，需要一行一行地检查代码，这个时候，只有掌握Java内存模型，才能慧眼如炬地发现问题。</p><h2>什么是Java内存模型？</h2><p>你已经知道，导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong>，但是这样问题虽然解决了，我们程序的性能可就堪忧了。</p><p>合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>。那么，如何做到“按需禁用”呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。</p><!-- [[[read_end]]] --><p>Java内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final </strong>三个关键字，以及六项 <strong>Happens-Before 规则</strong>，这也正是本期的重点内容。</p><h2>使用volatile的困惑</h2><p>volatile关键字并不是Java语言的特产，古老的C语言里也有，它最原始的意义就是禁用CPU缓存。</p><p>例如，我们声明一个volatile变量 <code>volatile int x = 0</code>，它表达的是：告诉编译器，对这个变量的读写，不能使用CPU缓存，必须从内存中读取或者写入。这个语义看上去相当明确，但是在实际使用的时候却会带来困惑。</p><p>例如下面的示例代码，假设线程A执行writer()方法，按照 volatile 语义，会把变量 “v=true” 写入内存；假设线程B执行reader()方法，同样按照 volatile 语义，线程B会从内存中读取变量v，如果线程B看到 “v == true” 时，那么线程B看到的变量x是多少呢？</p><p>直觉上看，应该是42，那实际应该是多少呢？这个要看Java的版本，如果在低于1.5版本上运行，x可能是42，也有可能是0；如果在1.5以上的版本上运行，x就是等于42。</p><pre><code>// 以下代码来源于【参考1】
class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 42;
    v = true;
  }
  public void reader() {
    if (v == true) {
      // 这里x会是多少呢？
    }
  }
}
</code></pre><p>分析一下，为什么1.5以前的版本会出现x = 0的情况呢？我相信你一定想到了，变量x可能被CPU缓存而导致可见性问题。这个问题在1.5版本已经被圆满解决了。Java内存模型在1.5版本对volatile语义进行了增强。怎么增强的呢？答案是一项 Happens-Before 规则。</p><h2>Happens-Before 规则</h2><p>如何理解 Happens-Before 呢？如果望文生义（很多网文也都爱按字面意思翻译成“先行发生”），那就南辕北辙了，Happens-Before 并不是说前面一个操作发生在后续操作的前面，它真正要表达的是：<strong>前面一个操作的结果对后续操作是可见的</strong>。就像有心灵感应的两个人，虽然远隔千里，一个人心之所想，另一个人都看得到。Happens-Before 规则就是要保证线程之间的这种“心灵感应”。所以比较正式的说法是：Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。</p><p>Happens-Before 规则应该是Java内存模型里面最晦涩的内容了，和程序员相关的规则一共有如下六项，都是关于可见性的。</p><p>恰好前面示例代码涉及到这六项规则中的前三项，为便于你理解，我也会分析上面的示例代码，来看看规则1、2和3到底该如何理解。至于其他三项，我也会结合其他例子作以说明。</p><h3>1. 程序的顺序性规则</h3><p>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。这还是比较容易理解的，比如刚才那段示例代码，按照程序的顺序，第6行代码 “x = 42;” Happens-Before 于第7行代码 “v = true;”，这就是规则1的内容，也比较符合单线程里面的思维：程序前面对某个变量的修改一定是对后续操作可见的。</p><p><span class="orange">（为方便你查看，我将那段示例代码在这儿再呈现一遍）</span></p><pre><code>// 以下代码来源于【参考1】
class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 42;
    v = true;
  }
  public void reader() {
    if (v == true) {
      // 这里x会是多少呢？
    }
  }
}
</code></pre><h3>2. volatile变量规则</h3><p>这条规则是指对一个volatile变量的写操作， Happens-Before 于后续对这个volatile变量的读操作。</p><p>这个就有点费解了，对一个volatile变量的写操作相对于后续对这个volatile变量的读操作可见，这怎么看都是禁用缓存的意思啊，貌似和1.5版本以前的语义没有变化啊？如果单看这个规则，的确是这样，但是如果我们关联一下规则3，就有点不一样的感觉了。</p><h3>3. 传递性</h3><p>这条规则是指如果A Happens-Before B，且B Happens-Before C，那么A Happens-Before C。</p><p>我们将规则3的传递性应用到我们的例子中，会发生什么呢？可以看下面这幅图：</p><p><img src="https://static001.geekbang.org/resource/image/b1/e1/b1fa541e98c74bc2a033d9ac5ae7fbe1.png" alt=""></p><center><span class="reference">示例代码中的传递性规则</span></center><p>从图中，我们可以看到：</p><ol>
<li>“x=42” Happens-Before 写变量 “v=true” ，这是规则1的内容；</li>
<li>写变量“v=true” Happens-Before 读变量 “v=true”，这是规则2的内容 。</li>
</ol><p>再根据这个传递性规则，我们得到结果：“x=42” Happens-Before 读变量“v=true”。这意味着什么呢？</p><p>如果线程B读到了“v=true”，那么线程A设置的“x=42”对线程B是可见的。也就是说，线程B能看到 “x == 42” ，有没有一种恍然大悟的感觉？这就是1.5版本对volatile语义的增强，这个增强意义重大，1.5版本的并发工具包（java.util.concurrent）就是靠volatile语义来搞定可见性的，这个在后面的内容中会详细介绍。</p><h3>4. 管程中锁的规则</h3><p>这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p><p>要理解这个规则，就首先要了解“管程指的是什么”。<strong>管程</strong>是一种通用的同步原语，在Java中指的就是synchronized，synchronized是Java里对管程的实现。</p><p>管程中的锁在Java里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。</p><pre><code>synchronized (this) { //此处自动加锁
  // x是共享变量,初始值=10
  if (this.x &lt; 12) {
    this.x = 12; 
  }  
} //此处自动解锁
</code></pre><p>所以结合规则4——管程中锁的规则，可以这样理解：假设x的初始值是10，线程A执行完代码块后x的值会变成12（执行完自动释放锁），线程B进入代码块时，能够看到线程A对x的写操作，也就是线程B能够看到x==12。这个也是符合我们直觉的，应该不难理解。</p><h3>5. 线程 start() 规则</h3><p>这条是关于线程启动的。它是指主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作。</p><p>换句话说就是，如果线程A调用线程B的 start() 方法（即在线程A中启动线程B），那么该start()操作 Happens-Before 于线程B中的任意操作。具体可参考下面示例代码。</p><pre><code>Thread B = new Thread(()-&gt;{
  // 主线程调用B.start()之前
  // 所有对共享变量的修改，此处皆可见
  // 此例中，var==77
});
// 此处对共享变量var修改
var = 77;
// 主线程启动子线程
B.start();
</code></pre><h3>6. 线程 join() 规则</h3><p>这条是关于线程等待的。它是指主线程A等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join()方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对<strong>共享变量</strong>的操作。</p><p>换句话说就是，如果在线程A中，调用线程B的 join() 并成功返回，那么线程B中的任意操作Happens-Before 于该 join() 操作的返回。具体可参考下面示例代码。</p><pre><code>Thread B = new Thread(()-&gt;{
  // 此处对共享变量var修改
  var = 66;
});
// 例如此处对共享变量修改，
// 则这个修改结果对线程B可见
// 主线程启动子线程
B.start();
B.join()
// 子线程所有对共享变量的修改
// 在主线程调用B.join()之后皆可见
// 此例中，var==66
</code></pre><h2>被我们忽视的final</h2><p>前面我们讲volatile为的是禁用缓存以及编译优化，我们再从另外一个方面来看，有没有办法告诉编译器优化得更好一点呢？这个可以有，就是<strong>final关键字</strong>。</p><p><strong>final修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。</strong>Java编译器在1.5以前的版本的确优化得很努力，以至于都优化错了。</p><p>问题类似于上一期提到的利用双重检查方法创建单例，构造函数的错误重排导致线程可能看到final变量的值会变化。详细的案例可以参考<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#finalWrong">这个文档</a>。</p><p>当然了，在1.5以后Java内存模型对final类型变量的重排进行了约束。现在只要我们提供正确构造函数没有“逸出”，就不会出问题了。</p><p>“逸出”有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将this赋值给了全局变量global.obj，这就是“逸出”，线程通过global.obj读取x是有可能读到0的。因此我们一定要避免“逸出”。</p><pre><code>// 以下代码来源于【参考1】
final int x;
// 错误的构造函数
public FinalFieldExample() { 
  x = 3;
  y = 4;
  // 此处就是讲this逸出，
  global.obj = this;
}
</code></pre><h2>总结</h2><p>Java的内存模型是并发编程领域的一次重要创新，之后C++、C#、Golang等高级语言都开始支持内存模型。Java内存模型里面，最晦涩的部分就是Happens-Before规则了，Happens-Before规则最初是在一篇叫做<strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong>的论文中提出来的，在这篇论文中，Happens-Before的语义是一种因果关系。在现实世界里，如果A事件是导致B事件的起因，那么A事件一定是先于（Happens-Before）B事件发生的，这个就是Happens-Before语义的现实理解。</p><p>在Java语言里面，Happens-Before的语义本质上是一种可见性，A Happens-Before B 意味着A事件对B事件来说是可见的，无论A事件和B事件是否发生在同一个线程里。例如A事件发生在线程1上，B事件发生在线程2上，Happens-Before规则保证线程2上也能看到A事件的发生。</p><p>Java内存模型主要分为两部分，一部分面向你我这种编写并发程序的应用开发人员，另一部分是面向JVM的实现人员的，我们可以重点关注前者，也就是和编写并发程序相关的部分，这部分内容的核心就是Happens-Before规则。相信经过本章的介绍，你应该对这部分内容已经有了深入的认识。</p><h2>课后思考</h2><p>有一个共享变量 abc，在一个线程里设置了abc的值 <code>abc=3</code>，你思考一下，有哪些办法可以让其他线程能够看到<code>abc==3</code>？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><h2>参考</h2><ol>
<li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">JSR 133 (Java Memory Model) FAQ</a></li>
<li><a href="http://ifeve.com/jmm-faq/">Java内存模型FAQ</a></li>
<li><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">JSR-133: Java<sup>TM</sup> Memory Model and Thread Specification</a></li>
</ol><p><img src="https://static001.geekbang.org/resource/image/f3/9c/f3531b6230d4ebadc020e056ff5d009c.jpg" alt=""></p><h2>精选留言：</h2>
        <ul>
        
<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            Handongyang  2019-03-02 14:32:19
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            老师，还差两个规则，分别是：<br>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。<br>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。<br><br>所以，个人对于Java内存模型总结起来就是：<br>1. 为什么定义Java内存模型？现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。<br>2. 三个基本原则：原子性、可见性、有序性。<br>3. Java内存模型涉及的几个关键词：锁、volatile字段、final修饰符与对象的安全发布。其中：第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。<br>4. Happens-Before的7个规则：<br>	(1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。<br>	(2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而&quot;后面&quot;是指时间上的先后顺序。<br>	(3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的&quot;后面&quot;同样是指时间上的先后顺序。<br>	(4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。<br>	(5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。<br>	(6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。<br>	(7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。<br>5. Happens-Before的1个特性：传递性。<br>6. Java内存模型底层怎么实现的？主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。 [239赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 18:34:47</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">厉害厉害！！！</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            senekis  2019-03-02 01:11:37
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            <br>我思考下认为有三种方式可以实现:<br>1.声明共享变量abc，并使用volatile关键字修饰abc<br>2.声明共享变量abc，在synchronized关键字对abc的赋值代码块加锁，由于Happen-before管程锁的规则，可以使得后续的线程可以看到abc的值。<br>3.A线程启动后，使用A.JOIN()方法来完成运行，后续线程再启动，则一定可以看到abc==3<br><br>如有错误，请给指出错误所在！谢谢大家！谢谢老师！<br><br>听课后感觉对我帮助好大，以前零碎的知识被重新系统的整理。错误的理解也得到修正，感谢老师！ [59赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 17:43:03</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">这三种方式都正确，理解的不错！</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            Junzi  2019-03-04 00:34:56
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            参考1中write()方法代码：<br>x=45;  &#47;&#47; 1<br>v=true;  &#47;&#47; 2<br>这两行会不会导致指令重排？<br><br>因为volatile关键字应该只保证了变量v的可见性，happen-before第一条原则在单线程中，1与2重排并不影响结果，那应该有可能出现重排的情况，这样线程B读取到read()的时候也有可能出现x=0。还请老师解答。 [34赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            狂战俄洛伊  2019-03-02 12:43:10
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            回复tracer的问题@tracer，你说的这个问题其实就是一个happens-before原则。例如有以下代码：<br>     int a = 1;&#47;&#47;代码1<br>     int b = 2;&#47;&#47;代码2<br>     volatile int c = 3;&#47;&#47;代码3<br>     int d = 4;&#47;&#47;代码4<br>     int e = 5;&#47;&#47;代码5<br>编译器解释这5行代码的时候，会保证代码1和代码2会在代码3之前执行，而代码1和代码2的执行顺序则不一定（这就是重排序，在不影响执行结果的情况下，虚拟机可能会对命令重排。当然所谓的不影响执行结果，java只保证在单线程中不影响执行结果）。代码4和代码5也一定会在代码3之后执行，同理代码4和代码5的执行顺序也是不一定的。<br>    所以这篇文章中你说的那段代码，由于v是volatile修饰的，对v的赋值永远在对x的赋值之后。所以在reader中输出的x一定是42 [22赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 18:23:44</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">感谢回复！</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            Jerry银银  2019-03-02 13:33:41
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            思考题的通用性表述为：如何保证一个共享变量的可见性？<br>有以下方法：<br>1. 保证共享变量的可见性，使用volatile关键字修饰即可<br>2. 保证共享变量是private，访问变量使用set&#47;get方法，使用synchronized对方法加锁，此种方法不仅保证了可见性，也保证了线程安全<br>3. 使用原子变量，例如：AtomicInteger等<br>4. 最后一种不是办法的办法：保证多个线程是「串行执行」^_^ [15赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 18:26:08</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">很全面了!</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            发条橙子 。  2019-03-02 09:42:28
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            感悟 ： <br>老师用第一篇介绍了造成并发问题的由来引出了此文如果解决其中的 可见性、排序性问题 。 有了第一篇做铺垫让此篇看起来更加的流畅 。 <br><br>尤其以前看书中讲解 happens-before原则只是单单把六个规则点列了出来，很难吃透。此篇文章给出详细的事例逐点分析，使得更好的去理解每个点。 <br><br>例如 我之前看到的文章都说 在单线程中不会出现有序性问题 ，在多线程中会出现有序性问题。 之前很难理解单线程中没有有序性的问题是什么原因， 原来是happens-before第一条规则限制住了编译器的优化<br><br>问题： <br>第一个例子中添加了 volatile 关键字， 如果例子中 ， v变量没有使用volatile ，那么x会是什么呢 ？？<br>答案： 42<br><br>我的思考是， 没有了volatile那么规则二就不满足 ， 但是规则一和规则三还是满足 ，虽然 writer()方法修改 v不能让其他立即可见，但是如果是循环调用reader()方法 ，等到可见到 v == true，根据第一条原则 ， x happens-before v ，所以能读到 x=42 <br><br>老师请问我的判断正确么？<br><br><br>思考题 ：<br><br>一个共享变量在一个线程中修改让另其他线程可见， 那就是解决可见性（缓存）的问题 , happens-before的规则就是用于对可见性进行约束的<br><br>按照老师课中所讲 ：<br>思考如下：<br><br>  1. 第一条规则同线程中编译会保证顺序性 ， 和问题不符合 <br><br> 2. 第二条规则 ， 使用volatile关键字 ， 这个关键字可以让其他线程写之前先读最新的值，所以保证读到的是最新的值 ，可行<br><br>3. 第三条规则 ，传递性， 和问题不符<br><br>4. 第四条规则， 使用管程，由于是访问共享变量，如果是在syn中修改值只能保证当前线程下一次进入syn可以看见最新的值，其他线程直接访问还可能不是最新值 ， 不行<br><br>5. 第五条规则 ， 如果前提是其他线程都在 主线程修改abc变量后 start()，则可见<br><br>6. 第六条规则 ，如果前提是其他线程等 修改abc变量线程 join()执行，则可见<br><br>  7.   Final关键字， 由于final关键字表示已经定义了常量，任意线程都不可以修改， 不可用 <br><br>综上总结 ： <br><br>使用2 添加volatile可行 。在符合某些场景下时，56可让其他线程可见<br><br><br> [14赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 17:54:07</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">你分析的比我还要好！</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            小和尚笨南北  2019-03-02 21:42:20
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            补充一个： 在abc赋值后对一个volatile变量A进行赋值操作，然后在其他线程读取abc之前读取A的值，通过volatile的可见性和happen-before的传递性实现abc修改后对其他线程立即可见 [12赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-03 11:37:54</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">这个我称为炫技！</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            tracer  2019-03-02 11:55:41
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            我明白了，写先于读指的是不会因为cpu缓存，导致a线程已经写了，但是b线程没读到的情况。我错误理解成了b要读，一定要等a写完才行 [12赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 18:21:38</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">终于理解了！</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            WL  2019-03-02 11:25:36
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            想问一下老师最后关于逸出的例子，是因为有可能通过global.obj 可能访问到还没有初始化的this对象吗，但是将this赋值给global.obj不也是初始化时才赋值的吗，这部分不太理解，请老师指点一下 [9赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 18:19:29</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">有可能通过global.obj 可能访问到还没有初始化的this对象<br>将this赋值给global.obj时，this还没有初始化完，this还没有初始化完，this还没有初始化完。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            Nevermore  2019-03-02 10:07:45
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            &#47;&#47; 以下代码来源于【参考 1】<br>class VolatileExample {<br>  int x = 0;<br>  volatile boolean v = false;<br>  public void writer() {<br>    x = 42;<br>    v = true;<br>  }<br>  public void reader() {<br>    if (v == true) {<br>      &#47;&#47; 这里 x 会是多少呢？<br>    }<br>  }<br>}<br><br><br>感觉老师对这个volatile变量规则这块讲的有点草率，volatile变量的写对于读是可见的，对于程序来说，也就是线程A执行write中的v=true对于reader中的v==true是可见的 ，但是这对于x有什么关系？x并没有被volatile修饰。<br>根据我的理解，volatile强制所修饰的变量及它前边的变量刷新至内存，并且volatile禁止了指令的重排序。<br> <br>望指正<br> [8赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 18:05:49</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">你的理解是对的，volatile的实现就是这样的。指导JVM这么实现的规范就是内存模型。这个专栏的侧重点是让大家学会写并发程序，至于底层是怎么实现的，有精力和兴趣的同学，可以自己来把握。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            小麦  2019-03-04 21:33:57
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            @发条橙子 ... <br>有问题吧，我是这样理解的，第一条规则是串行语义，在单线程的场景下，优化后的结果会与顺序执行一致，但是不代表对x的写操作会比对v的写先执行，所以多线程下会出现问题。加volatile关键字后，volatile变量在写操作之后会插入一个store屏障（Store屏障，是x86的”sfence“指令，强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存。这会使得程序状态对其它CPU可见，这样其它CPU可以根据需要介入。--并发编程网），所以禁止了重排序，这才保证了对x的写操作会比对v的写先执行，然后再根据volatile变量规则跟传递性原则，才保证了x=42对线程B可见。<br><br> [7赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            强哥  2019-03-02 16:47:52
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            关于java内存模型、jvm内存结构及java对象模型分别深入讲解一下，这样效果更好一些。 [7赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 18:40:25</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">咱们这个专栏还是专注于并发相关的部分，我怕有人说挂羊头卖狗肉</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            magict4  2019-03-04 05:54:30
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            老师你好，<br><br>我对『3. 传递性』中您的解释，还是有点疑惑。感觉许多留言的小伙伴们也都有类似的疑惑，还请老师再耐心回答一次。<br><br>您提到：<br>&gt; “x=42” Happens-Before 写变量 “v=true” ，这是规则 1 的内容；<br>我的疑惑：变量 x 和 v 没有任何依赖关系，为什么对 x 的赋值 Happens-Before 对 v 的赋值呢？<br><br>这个 Happens-Before 关系，根据我的理解，不是由规则 1 决定的，而是有 volatile 决定的。如果 v 没有被 volatile 修饰，编译器是可以对 x、v 的赋值语句进行重排的。 不知道我的理解是否有问题？ [6赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-04 22:57:50</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">“x=42” Happens-Before 写变量 “v=true”<br>是因为程序顺序就是这么写的：x=42；v=true<br><br>这个案例是综合了 程序的顺序规则+传递规则+volatile 规则<br><br>这三这个规则组合在一起就是你所谓的：“而是有 volatile 决定的”。编译器优化要遵循所有的HB规则。所有，不是一条。所以只有把他们组合在一起才有意义。<br></div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            李  2019-03-03 07:30:34
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            老师，第一章里提到程序中x=5；x=6可能被重排。可是今天第一个规则里提到，同一个线程里，是顺序的。这两个不就矛盾了吗？ [5赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-03 11:22:19</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">可以重排，但是要保证符合Happens-Before规则，Happens-Before规则关注的是可见性，<br>x=5;<br>y=6;<br>z=x+y;<br>上面的代码重排成这样：<br>y=6;<br>x=5;<br>z=x+y;<br>也是可以的。<br><br>所谓顺序，指的是你可以用顺序的方式推演程序的执行，但是程序的执行不一定是完全顺序的。编译器保证结果一定 == 顺序方式推演的结果<br><br>这几条规则，都是告诉你，可以按照这个规则推演程序的执行。但是编译怎么优化，那就百花齐放了。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            飞翔的花狸猫  2019-03-02 11:05:10
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            Happen-before 这个知识点终于理解了，追并发专栏比以前看小说还勤快，盼老师速更啊 [4赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 18:18:03</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">那小说得写的有多烂！</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            峰  2019-03-02 09:45:55
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            我觉得课后题其实就是利用happenbefore规则去构建abc的写入happenfore于另外一个线程的读取。而6条规则中传递性规则是纽带，然后采用比如规则4，就是把abc的赋值加入一同步块，并先执行，同时另外一个线程申请同一把锁即可。其他的也类似。<br><br>java内存模型对程序员来说提供了按需禁止缓存禁止指令重排的方法。这是我第一次看到这么简单又深刻的解释，老师棒棒哒！！！ [4赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-02 17:54:48</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">多谢鼓励啊！</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            鸠翱  2019-03-04 20:15:13
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            对于@Junzi的问题：<br>x=45; &#47;&#47; 1<br>v=true; &#47;&#47; 2<br>这两行会不会导致指令重排？ 答：不会<br>如果这两行重排序了，那么线程B读取到read()的时候也有可能出现x=0，也就是说线程B看到了v=true却没又看到x=45，这不符合第一条规则（请问老师 这么理解对不对）<br>我课外查询了一下，从实现方法上，volatile的读写前后会插入内存屏障，保证一些操作是无法没重排序的，其中就有对于volatile的写操作之前的动作不会被重排序到之后 [3赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-04 22:37:24</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">是这样。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            王位庆  2019-04-03 22:35:39
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            @Junzi，您提的问题刚开始我也很疑惑，但查看了java并发编程的艺术，书上写了jdk1.5之后，增强了volatile的内存含义，限制了编译器和处理器对volatile变量和普通变量的重排序。p47页 [2赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            Hello,Hello,Hello Kitty  2019-03-11 22:29:45
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            x = 42;<br>v = true;<br>老师 我想请假一下 x并没有加volatile修饰 JVM是如何保证x的结果也是被可见呢 是因为x跟v都在同一个寄存器中 voatile修饰的v被刷新回内存的时候 整个寄存器中的值都被刷新到内存中了吗？<br> [2赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-11 22:58:37</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">这方面，我也很难通透地讲清楚从Java代码到CPU指令的过程，单线程保证x可见很容易，多线程x跟v不能都同时在一个寄存器里。voatile v刷新回内存的时候，所有CPU缓存里的值都会失效。下次访问就能访问到新的了。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;line-height:1.2">
            乔宇佳  2019-03-06 18:33:06
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">
            关于Junzi的问题，你在自己说的时候已经回答了，因为重排后会影响结果，如果重排之后在读的时候可能会读到0<br>如果v之前有多条指令，那么之前的那多条指令会重排因为那不会影响结果，如果只有这两条，是不会重排的。<br><br>第一次回留言，语言组织的不太好，望老师指正！ [2赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;line-height:1.2">作者回复2019-03-06 22:24:45</div>
    <div style="color:#353535;font-weight:400;white-space:normal;word-break:break-all;line-height:1.6">是的，我也觉得实际上不会重排。这个例子只是说理论上会出问题。你回答的比我要好。</div>
</div>
            
    </div>
</li>
            </ul>
</div>
</body>
</html>